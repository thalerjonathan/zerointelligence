
==================== FINAL INTERFACE ====================
2019-03-13 02:39:43.365243536 UTC

interface main:Main 8022
  interface hash: 49cdcaf8dc524fa9276b4abf55ac6600
  ABI hash: 04ce776d638a624fc2d594357bef2207
  export-list hash: fc8fe194abe786749f79894fb88b3707
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c331e677e39bffd6ede6695631157dec
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.buyersCount
  Main.findTrade
  Main.iteration
  Main.iterations
  Main.main
  Main.maxCost
  Main.maxValue
  Main.randElem
  Main.removeElem
  Main.rngSeed
  Main.runSimulation
  Main.sellersCount
  Main.Buyer{Main.Buyer}
  Main.Market{Main.Market bestAsk bestBid buyers prices sellers surplus tradedCosts tradedValues}
  Main.Offer{Main.Offer}
  Main.Price
  Main.Seller{Main.Seller}
  Main.Trade{Main.Trade}
  Main.TradeInfo{Main.ImproveAsk Main.ImproveBid Main.Match Main.NoTrade}
module dependencies:
package dependencies: MonadRandom-0.5.1.1 array-0.5.2.0
                      base-4.10.1.0* deepseq-1.4.3.0 ghc-prim-0.5.1.1 integer-gmp-1.0.1.0
                      mtl-2.2.2 primitive-0.6.4.0 random-1.1* time-1.8.0.2
                      transformers-0.5.2.0
orphans: transformers-0.5.2.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: MonadRandom-0.5.1.1:Control.Monad.Trans.Random.Lazy
                         base-4.10.1.0:Control.Applicative base-4.10.1.0:Data.Complex
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Compose
                         base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
                         primitive-0.6.4.0:Control.Monad.Primitive
import  -/  MonadRandom-0.5.1.1:Control.Monad.Random 45087cae4f9beae03a19562b0b9f9c26
import  -/  MonadRandom-0.5.1.1:Control.Monad.Random.Class 7bed22c3f1525ee75da4ec914b6ed225
import  -/  MonadRandom-0.5.1.1:Control.Monad.Trans.Random.Lazy bad629cfd00f929094dba942d570f0f4
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.Functor 2ffda4f936b8f474394d93205750aff3
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.IO.Handle 5f614cc041d5fa954b0de4d7c73104fe
import  -/  base-4.10.1.0:GHC.IO.Handle.FD e06fbff6d2dafa211cd5a82e8b1f2f2d
import  -/  base-4.10.1.0:GHC.IO.Handle.Text f965c72d2e9a995ca335a979dc85c98d
import  -/  base-4.10.1.0:GHC.IO.IOMode 2f4ee5a150324cf00a91bc1369bfe932
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  base-4.10.1.0:Text.Printf 3260e305614fadf610f6d8134e12b571
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  random-1.1:System.Random 1f9783c2e4f478be012ca03febf119ac
5e029d9543ee2fa2af8c91fc76535a2f
  $tc'Buyer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9567889530862180656##
                   1864304413531944644##
                   Main.$trModule
                   Main.$tc'Buyer2
                   0#
                   Main.$tc'Buyer1) -}
0a24375b146617f3fc04ea83f340e9df
  $tc'Buyer1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d6c1b356a0cbf0bf312c2ee949058082
  $tc'Buyer2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Buyer3) -}
0c24c5ed3230a6a722b8e11b4aa7c1ef
  $tc'Buyer3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Buyer"#) -}
b08ae38480902735f742905e793422c7
  $tc'ImproveAsk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6618258082530294849##
                   17943774561316873821##
                   Main.$trModule
                   Main.$tc'ImproveAsk2
                   0#
                   Main.$tc'ImproveAsk1) -}
42957ecd0ca1d9c2d2a7dcf0fc49af55
  $tc'ImproveAsk1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4bb2659e589031be962a8c5feed84e81
  $tc'ImproveAsk2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'ImproveAsk3) -}
596d6e0a58ef5919c431a726a294c133
  $tc'ImproveAsk3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImproveAsk"#) -}
09d8ab7f390cd54f80aea2b6bcc7c4e7
  $tc'ImproveBid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12661386525319555304##
                   7939371891807673943##
                   Main.$trModule
                   Main.$tc'ImproveBid1
                   0#
                   Main.$tc'ImproveAsk1) -}
cf45cd7362bf7ed7645879fb9cfe3ce8
  $tc'ImproveBid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'ImproveBid2) -}
6023783d42e491f6a71f1bad4a564b00
  $tc'ImproveBid2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ImproveBid"#) -}
b7f0f7898011a8b8f258e6c1f2f694c8
  $tc'Market :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4769392951377415897##
                   3116084075762673865##
                   Main.$trModule
                   Main.$tc'Market2
                   0#
                   Main.$tc'Market1) -}
b4a95a03349072012db4579e65a5452d
  $tc'Market1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
62ab70bbc97539e2a04f8181f521eeac
  $tc'Market2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Market3) -}
d042e36194ac3ab26d99f4af08b77cdf
  $tc'Market3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Market"#) -}
7b37da3b460c9845336340313d61d017
  $tc'Match :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16365425849956540769##
                   17501440565446300163##
                   Main.$trModule
                   Main.$tc'Match2
                   0#
                   Main.$tc'Match1) -}
f7c1a59bbbe38377b5d719f3c4b1955b
  $tc'Match1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3d00365417905c8c88436bce191ee1ed
  $tc'Match2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Match3) -}
bb953c8000a5e05b6e865d2ac7314ba8
  $tc'Match3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Match"#) -}
d9c43b3b216f0d52a318abe233d4671a
  $tc'NoTrade :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10947710188104211925##
                   11151795699598426391##
                   Main.$trModule
                   Main.$tc'NoTrade2
                   0#
                   Main.$tc'NoTrade1) -}
01efc2a645f1c5cdfab46ecb5a01b90b
  $tc'NoTrade1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
d6efb3df9feea7b9e58270757de78c51
  $tc'NoTrade2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'NoTrade3) -}
ef8b357af0501071093b6df55d8a7449
  $tc'NoTrade3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NoTrade"#) -}
5d331ae4a7e576d4410075c553183f49
  $tc'Offer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9191348395569951841##
                   14163099286778986178##
                   Main.$trModule
                   Main.$tc'Offer2
                   0#
                   Main.$tc'Offer1) -}
0e3423ba6554b97e5db39e93afc5afc3
  $tc'Offer1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3e735de3e2fc6821ec9910dc8fb0230b
  $tc'Offer2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Offer3) -}
f907837a1e1a9cebf332108e6b0d1bb5
  $tc'Offer3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Offer"#) -}
7ea58a7c492f94a2a024be1fd7a865a1
  $tc'Seller :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10210799928756784821##
                   13754925244778819493##
                   Main.$trModule
                   Main.$tc'Seller2
                   0#
                   Main.$tc'Seller1) -}
75787ccc4a04e9cdec79e711551a36c7
  $tc'Seller1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7180827c678201a8b26c4470bbeb2dd8
  $tc'Seller2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Seller3) -}
c4ee1ec60f0274123b7bb65340d80b55
  $tc'Seller3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Seller"#) -}
326bd40833f63e21c63b7edc1165ad3c
  $tc'Trade :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17353198502535580801##
                   10252121016657135040##
                   Main.$trModule
                   Main.$tc'Trade2
                   0#
                   Main.$tc'Trade1) -}
41d93f0bfff64ce75a0f87d500418970
  $tc'Trade1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
343043137ef38f2e121e84a0035cb9a6
  $tc'Trade2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Trade3) -}
8e462b4c7aff1f297c05b431395f565c
  $tc'Trade3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Trade"#) -}
af241192673a205291cb5cb70bca812b
  $tcBuyer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8004295767179431695##
                   11342202979818830096##
                   Main.$trModule
                   Main.$tcBuyer1
                   0#
                   GHC.Types.krep$*) -}
23cca00103fd7b7b882267309fa5767b
  $tcBuyer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcBuyer2) -}
66a3cec00fa91dc25a8a77aae1f0cdc9
  $tcBuyer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Buyer"#) -}
5a3f7f82225333cb47ebd8e1f3b353ad
  $tcMarket :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17723839539091948801##
                   4583209549958302597##
                   Main.$trModule
                   Main.$tcMarket1
                   0#
                   GHC.Types.krep$*) -}
c8fdb70da3c958c2d36e9bd049090d21
  $tcMarket1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcMarket2) -}
73e0d1360ebfaf8b2b926d383c12c6c9
  $tcMarket2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Market"#) -}
6aacb179ea28696cf20de1558dd6f5e3
  $tcOffer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3654263810382147922##
                   3174955847414980299##
                   Main.$trModule
                   Main.$tcOffer1
                   0#
                   GHC.Types.krep$*) -}
c8e7a9acf685878adfc7df504a7a1171
  $tcOffer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcOffer2) -}
f2b5ce5cc892ae70ba3a40217b45c796
  $tcOffer2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Offer"#) -}
f0a2b6aa4f5f3dd224b385d021d62358
  $tcSeller :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13739562082855688980##
                   9769562677097175808##
                   Main.$trModule
                   Main.$tcSeller1
                   0#
                   GHC.Types.krep$*) -}
cb4349665303b12d97fe29380ecc7b67
  $tcSeller1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcSeller2) -}
73181617f62642852ab181c537ed4004
  $tcSeller2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Seller"#) -}
5ebd33a509431def5e20473d26865cd2
  $tcTrade :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13812397603186923680##
                   6478041273538622376##
                   Main.$trModule
                   Main.$tcTrade1
                   0#
                   GHC.Types.krep$*) -}
da4f5d47305ebd80f8c3dc6517ea39d0
  $tcTrade1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTrade2) -}
104021eb2c58e0ce5b778087ebae0ee4
  $tcTrade2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Trade"#) -}
72a3b741dc96d816f33aee6412019067
  $tcTradeInfo :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6108090980504172525##
                   18401682414732908741##
                   Main.$trModule
                   Main.$tcTradeInfo1
                   0#
                   GHC.Types.krep$*) -}
43ca78bf60595087f027f09339c3dd1c
  $tcTradeInfo1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTradeInfo2) -}
eb5b81dd6288663e245dc5662d4ea2d8
  $tcTradeInfo2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TradeInfo"#) -}
9d72b2fddb818bcd8919052935e0f1f3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
3108ceeaf5a318be844de422b45de9d8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
33bd129667974f0a0ba4a893af79107d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
132d65e8e2e5ec9648b0538db0f4109e
  $w$sfindTrade ::
    [Main.Seller]
    -> [Main.Buyer]
    -> GHC.Base.Maybe Main.Offer
    -> GHC.Base.Maybe Main.Offer
    -> System.Random.StdGen
    -> (# Main.TradeInfo, System.Random.StdGen #)
  {- Arity: 5, Strictness: <L,U><L,U><L,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Main.Seller])
                   (ww1 :: [Main.Buyer])
                   (ww2 :: GHC.Base.Maybe Main.Offer)
                   (ww3 :: GHC.Base.Maybe Main.Offer)
                   (w :: System.Random.StdGen) ->
                 case System.Random.$wrandomIvalInteger
                        @ System.Random.StdGen
                        @ GHC.Types.Int
                        System.Random.$fRandomGenStdGen
                        GHC.Num.$fNumInt
                        System.Random.$dmrandomIO3
                        System.Random.$fRandomBool3
                        w of ww4 { (#,#) ww5 ww6 ->
                 case ww5 of wild2 { GHC.Types.I# ds ->
                 case ds of ds1 {
                   DEFAULT
                   -> case Main.$w$srandElem
                             @ Main.Buyer
                             ww1
                             ww6 of ww7 { (#,#) ww8 ww9 ->
                      case ww8 of wild { (,) rb bi ->
                      let {
                        ds2 :: (GHC.Types.Double, System.Random.StdGen)
                        = System.Random.$fRandomDouble_$s$crandomR
                            (Main.findTrade2, rb `cast` (Main.N:Buyer[0]))
                            ww9
                      } in
                      case ww2 of wild1 {
                        GHC.Base.Nothing
                        -> case ww3 of wild3 {
                             GHC.Base.Nothing
                             -> (# Main.ImproveBid
                                     (Main.Offer (case ds2 of wild4 { (,) a1 s' -> a1 }) bi),
                                   case ds2 of wild4 { (,) a1 s' -> s' } #)
                             GHC.Base.Just ds3
                             -> case ds3 of wild4 { Main.Offer bestBidPrice ds4 ->
                                case ds2 of wild5 { (,) a1 s' ->
                                case a1 of wild6 { GHC.Types.D# x ->
                                case bestBidPrice of wild7 { GHC.Types.D# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.>## x y) of wild8 {
                                  GHC.Types.False -> (# Main.NoTrade, s' #)
                                  GHC.Types.True
                                  -> (# Main.ImproveBid (Main.Offer wild6 bi), s' #) } } } } } }
                        GHC.Base.Just ds3
                        -> case ds3 of wild3 { Main.Offer bestAskPrice si ->
                           case ds2 of wild4 { (,) a1 s' ->
                           case a1 of wild5 { GHC.Types.D# x ->
                           case bestAskPrice of wild6 { GHC.Types.D# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## x y) of wild7 {
                             GHC.Types.False -> (# Main.NoTrade, s' #)
                             GHC.Types.True
                             -> (# Main.Match
                                     (let {
                                        ds4 :: Main.Seller
                                        = case si of ww10 { GHC.Types.I# ww11 ->
                                          GHC.List.$w!! @ Main.Seller ww ww11 }
                                      } in
                                      Main.Trade
                                        wild6
                                        (case rb
                                                `cast`
                                              (Main.N:Buyer[0]) of wild8 { GHC.Types.D# x1 ->
                                         case ds4
                                                `cast`
                                              (Main.N:Seller[0]) of wild9 { GHC.Types.D# y1 ->
                                         GHC.Types.D# (GHC.Prim.-## x1 y1) } })
                                        bi
                                        si
                                        rb `cast` (Main.N:Buyer[0])
                                        ds4 `cast` (Main.N:Seller[0])),
                                   s' #) } } } } } } } }
                   0#
                   -> case Main.$w$srandElem
                             @ Main.Seller
                             ww
                             ww6 of ww7 { (#,#) ww8 ww9 ->
                      case ww8 of wild { (,) rs si ->
                      let {
                        ds2 :: (GHC.Types.Double, System.Random.StdGen)
                        = System.Random.$fRandomDouble_$s$crandomR
                            (rs `cast` (Main.N:Seller[0]), Main.maxCost)
                            ww9
                      } in
                      case ww3 of wild1 {
                        GHC.Base.Nothing
                        -> case ww2 of wild3 {
                             GHC.Base.Nothing
                             -> (# Main.ImproveAsk
                                     (Main.Offer (case ds2 of wild4 { (,) a1 s' -> a1 }) si),
                                   case ds2 of wild4 { (,) a1 s' -> s' } #)
                             GHC.Base.Just ds3
                             -> case ds3 of wild4 { Main.Offer bestAskPrice ds4 ->
                                case ds2 of wild5 { (,) a1 s' ->
                                case a1 of wild6 { GHC.Types.D# x ->
                                case bestAskPrice of wild7 { GHC.Types.D# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<## x y) of wild8 {
                                  GHC.Types.False -> (# Main.NoTrade, s' #)
                                  GHC.Types.True
                                  -> (# Main.ImproveBid (Main.Offer wild6 si), s' #) } } } } } }
                        GHC.Base.Just ds3
                        -> case ds3 of wild3 { Main.Offer bestBidPrice bi ->
                           case bestBidPrice of wild4 { GHC.Types.D# x ->
                           case ds2 of wild5 { (,) a1 s' ->
                           case a1 of wild6 { GHC.Types.D# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## x y) of wild7 {
                             GHC.Types.False -> (# Main.NoTrade, s' #)
                             GHC.Types.True
                             -> (# Main.Match
                                     (let {
                                        ds4 :: Main.Buyer
                                        = case bi of ww10 { GHC.Types.I# ww11 ->
                                          GHC.List.$w!! @ Main.Buyer ww1 ww11 }
                                      } in
                                      Main.Trade
                                        wild4
                                        (case ds4
                                                `cast`
                                              (Main.N:Buyer[0]) of wild8 { GHC.Types.D# x1 ->
                                         case rs
                                                `cast`
                                              (Main.N:Seller[0]) of wild9 { GHC.Types.D# y1 ->
                                         GHC.Types.D# (GHC.Prim.-## x1 y1) } })
                                        bi
                                        si
                                        ds4 `cast` (Main.N:Buyer[0])
                                        rs `cast` (Main.N:Seller[0])),
                                   s' #) } } } } } } } } } } }) -}
a491ed297d1e76f5197daad11abfd980
  $w$siteration ::
    GHC.Prim.Int#
    -> Main.Market
    -> System.Random.StdGen
    -> (# Main.Market, System.Random.StdGen #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U,U,U,U(U),U,U)><L,U>,
     Inline: [0] -}
235584b5fa93ce472c883c9307232aee
  $w$srandElem ::
    [a]
    -> System.Random.StdGen
    -> (# (a, GHC.Types.Int), System.Random.StdGen #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a (w :: [a]) (w1 :: System.Random.StdGen) ->
                 let {
                   ds :: (GHC.Types.Int, System.Random.StdGen)
                   = case GHC.List.$wlenAcc @ a w 0# of ww2 { DEFAULT ->
                     case System.Random.$wrandomIvalInteger
                            @ System.Random.StdGen
                            @ GHC.Types.Int
                            System.Random.$fRandomGenStdGen
                            GHC.Num.$fNumInt
                            Main.findTrade3
                            (GHC.Integer.Type.smallInteger (GHC.Prim.-# ww2 1#))
                            w1 of ww1 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } }
                 } in
                 (# let {
                      ri :: GHC.Types.Int = case ds of wild { (,) a1 s' -> a1 }
                    } in
                    (GHC.List.!! @ a w ri, ri),
                    case ds of wild { (,) a1 s' -> s' } #)) -}
dac50f5a5b2c95123efd447a74c73550
  $w$srunSimulation ::
    System.Random.StdGen -> (# [Main.Price], System.Random.StdGen #)
  {- Arity: 1, Strictness: <L,1*U(U,U)>, Inline: [0],
     Unfolding: (\ (w :: System.Random.StdGen) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           (Main.Market, System.Random.StdGen)
                   = let {
                       ds1 :: (System.Random.StdGen, System.Random.StdGen)
                       = case w of ww { System.Random.StdGen ww1 ww2 ->
                         case System.Random.$w$csplit ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                         (ww4, ww5) } }
                     } in
                     let {
                       ds2 :: (System.Random.StdGen, System.Random.StdGen)
                       = case ds1 of wild { (,) x1 y ->
                         case y of ww { System.Random.StdGen ww1 ww2 ->
                         case System.Random.$w$csplit ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                         (ww4, ww5) } } }
                     } in
                     case Main.iteration_$s$w$siteration
                            (case ds2 of wild { (,) x1 y -> y })
                            (Main.$wgo1 (case ds1 of wild { (,) x1 y -> x1 }) 500#)
                            (Main.$wgo (case ds2 of wild { (,) x1 y -> x1 }) 500#)
                            (GHC.Base.Nothing @ Main.Offer)
                            (GHC.Base.Nothing @ Main.Offer)
                            (GHC.Types.[] @ Main.Price)
                            0.0##
                            (GHC.Types.[] @ Main.Price)
                            (GHC.Types.[] @ Main.Price)
                            50000# of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <(Main.Market, System.Random.StdGen)>_R)) }
                 } in
                 (# case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(Main.Market, System.Random.StdGen)>_R) of wild { (,) a1 s' ->
                    case a1 of wild1 { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                    ds5 } },
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(Main.Market, System.Random.StdGen)>_R) of wild { (,) a1 s' ->
                    s' } #)) -}
5cd10c2699cbee6c5633ecfd3a98fae1
  $wfindTrade ::
    System.Random.RandomGen g =>
    [Main.Seller]
    -> [Main.Buyer]
    -> GHC.Base.Maybe Main.Offer
    -> GHC.Base.Maybe Main.Offer
    -> g
    -> (# Main.TradeInfo, g #)
  {- Arity: 6, Strictness: <L,U(U,U,U)><L,U><L,U><L,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ g
                   (w :: System.Random.RandomGen g)
                   (ww :: [Main.Seller])
                   (ww1 :: [Main.Buyer])
                   (ww2 :: GHC.Base.Maybe Main.Offer)
                   (ww3 :: GHC.Base.Maybe Main.Offer)
                   (w1 :: g) ->
                 case System.Random.$wrandomIvalInteger
                        @ g
                        @ GHC.Types.Int
                        w
                        GHC.Num.$fNumInt
                        System.Random.$dmrandomIO3
                        System.Random.$fRandomBool3
                        w1 of ww4 { (#,#) ww5 ww6 ->
                 case ww5 of wild2 { GHC.Types.I# ds ->
                 case ds of ds1 {
                   DEFAULT
                   -> case ((Main.randElem @ g @ Main.Buyer w ww1)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Random.Lazy.N:RandT[0] <g>_N <Data.Functor.Identity.Identity>_N <(Main.Buyer,
                                                                                                                        GHC.Types.Int)>_N)
                                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <g>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <(Main.Buyer, GHC.Types.Int)>_N))
                              ww6)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <((Main.Buyer, GHC.Types.Int), g)>_R) of wild { (,) a1 s' ->
                      case a1 of wild1 { (,) rb bi ->
                      let {
                        ds2 :: (GHC.Types.Double, g)
                        = System.Random.$fRandomDouble_$crandomR
                            @ g
                            w
                            (Main.findTrade2, rb `cast` (Main.N:Buyer[0]))
                            s'
                      } in
                      case ww2 of wild3 {
                        GHC.Base.Nothing
                        -> case ww3 of wild4 {
                             GHC.Base.Nothing
                             -> (# Main.ImproveBid
                                     (Main.Offer (case ds2 of wild5 { (,) a2 s'1 -> a2 }) bi),
                                   case ds2 of wild5 { (,) a2 s'1 -> s'1 } #)
                             GHC.Base.Just ds3
                             -> case ds3 of wild5 { Main.Offer bestBidPrice ds4 ->
                                case ds2 of wild6 { (,) a2 s'1 ->
                                case a2 of wild7 { GHC.Types.D# x ->
                                case bestBidPrice of wild8 { GHC.Types.D# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.>## x y) of wild9 {
                                  GHC.Types.False -> (# Main.NoTrade, s'1 #)
                                  GHC.Types.True
                                  -> (# Main.ImproveBid (Main.Offer wild7 bi), s'1 #) } } } } } }
                        GHC.Base.Just ds3
                        -> case ds3 of wild4 { Main.Offer bestAskPrice si ->
                           case ds2 of wild5 { (,) a2 s'1 ->
                           case a2 of wild6 { GHC.Types.D# x ->
                           case bestAskPrice of wild7 { GHC.Types.D# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## x y) of wild8 {
                             GHC.Types.False -> (# Main.NoTrade, s'1 #)
                             GHC.Types.True
                             -> (# Main.Match
                                     (let {
                                        ds4 :: Main.Seller
                                        = case si of ww7 { GHC.Types.I# ww8 ->
                                          GHC.List.$w!! @ Main.Seller ww ww8 }
                                      } in
                                      Main.Trade
                                        wild7
                                        (case rb
                                                `cast`
                                              (Main.N:Buyer[0]) of wild9 { GHC.Types.D# x1 ->
                                         case ds4
                                                `cast`
                                              (Main.N:Seller[0]) of wild10 { GHC.Types.D# y1 ->
                                         GHC.Types.D# (GHC.Prim.-## x1 y1) } })
                                        bi
                                        si
                                        rb `cast` (Main.N:Buyer[0])
                                        ds4 `cast` (Main.N:Seller[0])),
                                   s'1 #) } } } } } } } }
                   0#
                   -> case ((Main.randElem @ g @ Main.Seller w ww)
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Random.Lazy.N:RandT[0] <g>_N <Data.Functor.Identity.Identity>_N <(Main.Seller,
                                                                                                                        GHC.Types.Int)>_N)
                                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <g>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <(Main.Seller, GHC.Types.Int)>_N))
                              ww6)
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <((Main.Seller, GHC.Types.Int), g)>_R) of wild { (,) a1 s' ->
                      case a1 of wild1 { (,) rs si ->
                      let {
                        ds2 :: (GHC.Types.Double, g)
                        = System.Random.$fRandomDouble_$crandomR
                            @ g
                            w
                            (rs `cast` (Main.N:Seller[0]), Main.maxCost)
                            s'
                      } in
                      case ww3 of wild3 {
                        GHC.Base.Nothing
                        -> case ww2 of wild4 {
                             GHC.Base.Nothing
                             -> (# Main.ImproveAsk
                                     (Main.Offer (case ds2 of wild5 { (,) a2 s'1 -> a2 }) si),
                                   case ds2 of wild5 { (,) a2 s'1 -> s'1 } #)
                             GHC.Base.Just ds3
                             -> case ds3 of wild5 { Main.Offer bestAskPrice ds4 ->
                                case ds2 of wild6 { (,) a2 s'1 ->
                                case a2 of wild7 { GHC.Types.D# x ->
                                case bestAskPrice of wild8 { GHC.Types.D# y ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<## x y) of wild9 {
                                  GHC.Types.False -> (# Main.NoTrade, s'1 #)
                                  GHC.Types.True
                                  -> (# Main.ImproveBid (Main.Offer wild7 si), s'1 #) } } } } } }
                        GHC.Base.Just ds3
                        -> case ds3 of wild4 { Main.Offer bestBidPrice bi ->
                           case bestBidPrice of wild5 { GHC.Types.D# x ->
                           case ds2 of wild6 { (,) a2 s'1 ->
                           case a2 of wild7 { GHC.Types.D# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>## x y) of wild8 {
                             GHC.Types.False -> (# Main.NoTrade, s'1 #)
                             GHC.Types.True
                             -> (# Main.Match
                                     (let {
                                        ds4 :: Main.Buyer
                                        = case bi of ww7 { GHC.Types.I# ww8 ->
                                          GHC.List.$w!! @ Main.Buyer ww1 ww8 }
                                      } in
                                      Main.Trade
                                        wild5
                                        (case ds4
                                                `cast`
                                              (Main.N:Buyer[0]) of wild9 { GHC.Types.D# x1 ->
                                         case rs
                                                `cast`
                                              (Main.N:Seller[0]) of wild10 { GHC.Types.D# y1 ->
                                         GHC.Types.D# (GHC.Prim.-## x1 y1) } })
                                        bi
                                        si
                                        ds4 `cast` (Main.N:Buyer[0])
                                        rs `cast` (Main.N:Seller[0])),
                                   s'1 #) } } } } } } } } } } }) -}
eec3f315ad668ef2e5e6e74d8bfde223
  $wgo :: System.Random.StdGen -> GHC.Prim.Int# -> [Main.Buyer]
  {- Arity: 2, Strictness: <L,U><S,1*U>m2, Inline: [0] -}
282842c988203c925ce12843e8198dce
  $wgo1 :: System.Random.StdGen -> GHC.Prim.Int# -> [Main.Seller]
  {- Arity: 2, Strictness: <L,U><S,1*U>m2, Inline: [0] -}
b5ec0368c10effc6d84a82e831d136f5
  $witeration ::
    System.Random.RandomGen g =>
    GHC.Prim.Int# -> Main.Market -> g -> (# Main.Market, g #)
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><S,1*U><L,U(U,U,U,U,U,U(U),U,U)><L,U>,
     Inline: [0] -}
8f6cc6bb1e21e459b68b65ca4e6a9641
  $wremoveElem :: GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Int#) (w :: [a]) ->
                 let {
                   n :: [a]
                   = let {
                       x :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 0#) of wild {
                       GHC.Types.False -> Main.$wunsafeDrop @ a x w GHC.Types.True -> w }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> n
                   GHC.Types.True
                   -> letrec {
                        $wgo2 :: [a] -> GHC.Prim.Int# -> [a]
                          {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                        = \ (w1 :: [a]) (ww1 :: GHC.Prim.Int#) ->
                          case w1 of wild1 {
                            [] -> n
                            : y ys
                            -> case ww1 of ds1 {
                                 DEFAULT -> GHC.Types.: @ a y ($wgo2 ys (GHC.Prim.-# ds1 1#))
                                 1# -> GHC.Types.: @ a y n } }
                      } in
                      $wgo2 w ww }) -}
48e15367a2ea3f69cb2af6ee5601d65b
  $wrunSimulation ::
    System.Random.RandomGen g => g -> (# [Main.Price], g #)
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U>, Inline: [0],
     Unfolding: (\ @ g (w :: System.Random.RandomGen g) (w1 :: g) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (Main.Market, g)
                   = let {
                       ds1 :: (g, g) = System.Random.split @ g w w1
                     } in
                     let {
                       ds2 :: (g, g)
                       = System.Random.split @ g w (case ds1 of wild { (,) x1 y -> y })
                     } in
                     case Main.$witeration
                            @ g
                            w
                            50000#
                            (Main.Market
                               (letrec {
                                  $wgo2 :: g -> GHC.Prim.Int# -> [Main.Seller]
                                    {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
                                  = \ (w2 :: g) (ww :: GHC.Prim.Int#) ->
                                    case System.Random.$fRandomDouble_$crandomR
                                           @ g
                                           w
                                           Main.runSimulation_ival
                                           w2 of wild { (,) x g' ->
                                    case x of x1 { GHC.Types.D# ipv ->
                                    case ww of ds3 {
                                      DEFAULT
                                      -> GHC.Types.:
                                           @ Main.Seller
                                           x1 `cast` (Sym (Main.N:Seller[0]))
                                           ($wgo2 g' (GHC.Prim.-# ds3 1#))
                                      1#
                                      -> GHC.Types.:
                                           @ Main.Seller
                                           x1 `cast` (Sym (Main.N:Seller[0]))
                                           (GHC.Types.[] @ Main.Seller) } } }
                                } in
                                $wgo2 (case ds1 of wild { (,) x1 y -> x1 }) 500#)
                               (letrec {
                                  $wgo2 :: g -> GHC.Prim.Int# -> [Main.Buyer]
                                    {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
                                  = \ (w2 :: g) (ww :: GHC.Prim.Int#) ->
                                    case System.Random.$fRandomDouble_$crandomR
                                           @ g
                                           w
                                           Main.runSimulation_ival
                                           w2 of wild { (,) x g' ->
                                    case x of x1 { GHC.Types.D# ipv ->
                                    case ww of ds3 {
                                      DEFAULT
                                      -> GHC.Types.:
                                           @ Main.Buyer
                                           x1 `cast` (Sym (Main.N:Buyer[0]))
                                           ($wgo2 g' (GHC.Prim.-# ds3 1#))
                                      1#
                                      -> GHC.Types.:
                                           @ Main.Buyer
                                           x1 `cast` (Sym (Main.N:Buyer[0]))
                                           (GHC.Types.[] @ Main.Buyer) } } }
                                } in
                                $wgo2 (case ds2 of wild { (,) x1 y -> x1 }) 500#)
                               (GHC.Base.Nothing @ Main.Offer)
                               (GHC.Base.Nothing @ Main.Offer)
                               (GHC.Types.[] @ Main.Price)
                               Main.findTrade2
                               (GHC.Types.[] @ Main.Price)
                               (GHC.Types.[] @ Main.Price))
                            (case ds2 of wild { (,) x1 y -> y }) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0] <(Main.Market, g)>_R)) }
                 } in
                 (# case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(Main.Market, g)>_R) of wild { (,) a1 s' ->
                    case a1 of wild1 { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                    ds5 } },
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(Main.Market, g)>_R) of wild { (,) a1 s' ->
                    s' } #)) -}
00bb2257859340c278f030fbdf7c8098
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
b690c5758e9357430bb6057343ffa3fd
  newtype Buyer = Buyer GHC.Types.Double
1c0f2186a15c1342faa9a1b9d29eab6d
  data Market
    = Market {sellers :: [Main.Seller],
              buyers :: [Main.Buyer],
              bestAsk :: GHC.Base.Maybe Main.Offer,
              bestBid :: GHC.Base.Maybe Main.Offer,
              prices :: [Main.Price],
              surplus :: Main.Price,
              tradedValues :: [Main.Price],
              tradedCosts :: [Main.Price]}
513d4649eeedeb1327b41ee1cf006ee2
  data Offer = Offer Main.Price GHC.Types.Int
1f3a59524e87f1af4738cf120a00ee3a
  type Price = GHC.Types.Double
caa215b9247b12cdbd947e8dc2285349
  newtype Seller = Seller GHC.Types.Double
f9a20d48273941ea4d896ab3ce735293
  data Trade
    = Trade Main.Price
            Main.Price
            GHC.Types.Int
            GHC.Types.Int
            Main.Price
            Main.Price
a6427cd2e656aabfa756480062c01386
  data TradeInfo
    = Match Main.Trade
    | ImproveBid Main.Offer
    | ImproveAsk Main.Offer
    | NoTrade
1c0f2186a15c1342faa9a1b9d29eab6d
  bestAsk :: Main.Market -> GHC.Base.Maybe Main.Offer
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),1*U(A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds3 }) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  bestBid :: Main.Market -> GHC.Base.Maybe Main.Offer
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),1*U(A,A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds4 }) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  buyers :: Main.Market -> [Main.Buyer]
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),1*U(A,1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds2 }) -}
ffef1ce5a0deb590564bb0820df55997
  buyersCount :: GHC.Types.Int
  {- Strictness: m, Unfolding: (Main.sellersCount) -}
eae095cb6352e47a9a975ca242dd6f32
  findTrade ::
    System.Random.RandomGen g =>
    Main.Market
    -> Control.Monad.Trans.Random.Lazy.Rand g Main.TradeInfo
  {- Arity: 3,
     Strictness: <L,U(U,U,U)><S,1*U(U,U,1*U,1*U,A,A,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.findTrade1
                  `cast`
                (forall (g :: <*>_N).
                 <System.Random.RandomGen g>_R
                 ->_R <Main.Market>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <g>_N <Data.Functor.Identity.Identity>_R <Main.TradeInfo>_N))
                          (Sym (Control.Monad.Trans.Random.Lazy.N:RandT[0]) <g>_N <Data.Functor.Identity.Identity>_N <Main.TradeInfo>_N)) -}
bc0af5067d25fa9ab91b60a3f2753df6
  findTrade1 ::
    System.Random.RandomGen g =>
    Main.Market
    -> g -> Data.Functor.Identity.Identity (Main.TradeInfo, g)
  {- Arity: 3,
     Strictness: <L,U(U,U,U)><S,1*U(U,U,1*U,1*U,A,A,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ g
                   (w :: System.Random.RandomGen g)
                   (w1 :: Main.Market)
                   (w2 :: g) ->
                 case w1 of ww { Main.Market ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case Main.$wfindTrade
                        @ g
                        w
                        ww1
                        ww2
                        ww3
                        ww4
                        w2 of ww9 { (#,#) ww10 ww11 ->
                 (ww10, ww11)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(Main.TradeInfo, g)>_R)) } }) -}
905a86da63b6d23c55ffbe23165f370d
  findTrade2 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.0##) -}
52f62e14a3e3322b593f91402e6795ed
  findTrade3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
dbc6c012979ca39cdc52791efe6a3eb7
  iteration ::
    System.Random.RandomGen g =>
    GHC.Types.Int
    -> Main.Market
    -> Control.Monad.Trans.Random.Lazy.Rand g Main.Market
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><S(S),1*U(1*U)><L,U(U,U,U,U,U,U(U),U,U)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.iteration1
                  `cast`
                (forall (g :: <*>_N).
                 <System.Random.RandomGen g>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Main.Market>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <g>_N <Data.Functor.Identity.Identity>_R <Main.Market>_N))
                          (Sym (Control.Monad.Trans.Random.Lazy.N:RandT[0]) <g>_N <Data.Functor.Identity.Identity>_N <Main.Market>_N)) -}
e37e6bbc86fefe297db1099fea47b49f
  iteration1 ::
    System.Random.RandomGen g =>
    GHC.Types.Int
    -> Main.Market
    -> g
    -> Data.Functor.Identity.Identity (Main.Market, g)
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><S(S),1*U(1*U)><L,U(U,U,U,U,U,U(U),U,U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ g
                   (w :: System.Random.RandomGen g)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Market)
                   (w3 :: g) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case Main.$witeration @ g w ww1 w2 w3 of ww2 { (#,#) ww3 ww4 ->
                 (ww3, ww4)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(Main.Market, g)>_R)) } }) -}
2d4ca9ce01ec957acd8ab8e659aab690
  iteration_$s$w$siteration ::
    System.Random.StdGen
    -> [Main.Seller]
    -> [Main.Buyer]
    -> GHC.Base.Maybe Main.Offer
    -> GHC.Base.Maybe Main.Offer
    -> [GHC.Types.Double]
    -> GHC.Prim.Double#
    -> [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> GHC.Prim.Int#
    -> (# Main.Market, System.Random.StdGen #)
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,1*U> -}
f12d0624cd183b65c9567ae65bb6f843
  iterations :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 50000#) -}
e062378841e11fb4e9e107525747c079
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
ad168e6ee2cb637496de4b02d561b0e6
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.main8
                        GHC.IO.IOMode.WriteMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        ipv1
                        Main.main6
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case Main.$w$srunSimulation Main.main5 of ww { (#,#) ww1 ww2 ->
                 letrec {
                   go :: [Main.Price]
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [Main.Price])
                       (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case ds of wild {
                       []
                       -> case GHC.IO.Handle.Text.hPutStr2
                                 ipv1
                                 Main.main3
                                 GHC.Types.True
                                 eta of ds3 { (#,#) ipv4 ipv5 ->
                          GHC.IO.Handle.hClose1 ipv1 ipv4 }
                       : y ys
                       -> case GHC.IO.Handle.Text.hPutStr2
                                 ipv1
                                 (Text.Printf.uprintfs
                                    Main.main_fmts
                                    (GHC.List.reverse1
                                       @ Text.Printf.UPrintf
                                       (GHC.Types.:
                                          @ (Text.Printf.ModifierParser, Text.Printf.FieldFormatter)
                                          (Text.Printf.$fPrintfArgDouble_$cparseFormat y,
                                           Text.Printf.$fPrintfArgDouble_$sformatRealFloat y)
                                          (GHC.Types.[] @ Text.Printf.UPrintf))
                                       (GHC.Types.[] @ Text.Printf.UPrintf))
                                    (GHC.Types.[] @ GHC.Types.Char))
                                 GHC.Types.True
                                 eta of ds3 { (#,#) ipv4 ipv5 ->
                          go ys ipv4 } }
                 } in
                 go ww1 ipv2 } } }) -}
70bf0ed3539239bd99f04e241fc7574e
  main10 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
e42de18588a56b89a589cea272361f52
  main2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("%f"#) -}
e371daf6fa65339566addbf4d794102d
  main3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.main4) -}
01602367c2e285e21ccce4eab5d6e39c
  main4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("];"#) -}
72b60614fe66153963b91c197fa3cc18
  main5 :: System.Random.StdGen
  {- Unfolding: (case GHC.Int.$w$cdivMod1
                        42#
                        2147483562# of ww4 { (#,#) ww5 ww6 ->
                 case ww6 of wild { GHC.Int.I32# x# ->
                 case ww5 of ww2 { GHC.Int.I32# ww3 ->
                 case GHC.Classes.modInt# ww3 2147483398# of wild1 { DEFAULT ->
                 System.Random.StdGen
                   (GHC.Prim.narrow32Int# (GHC.Prim.+# x# 1#))
                   (GHC.Prim.narrow32Int#
                      (GHC.Prim.+# (GHC.Prim.narrow32Int# wild1) 1#)) } } } }) -}
dcb0385ac67fe7a9cbba89a04f117dac
  main6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.main7) -}
0c1b9f3d888c533e38925cf70ce58cc3
  main7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("prices = ["#) -}
f1b20d92b10ef9252ff999b608a8752f
  main8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.main9) -}
24c2bb6bfe0a71a5f0345bebbb5f3a9d
  main9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("prices.m"#) -}
654530fcc11925acc2886786a40e1f83
  main_fmts :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# Main.main2) -}
07f4638d99455980c6e83937778c6b80
  maxCost :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 25.0##) -}
745e1564588e91085821b2fa34b8a290
  maxValue :: GHC.Types.Double
  {- Strictness: m, Unfolding: (Main.maxCost) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  prices :: Main.Market -> [Main.Price]
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),1*U(A,A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds5 }) -}
791710ee13e98539b4b2c10b46477d4f
  randElem ::
    System.Random.RandomGen g =>
    [a] -> Control.Monad.Trans.Random.Lazy.Rand g (a, GHC.Types.Int)
  {- Arity: 2,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(1*U(U),1*U(U))),A)><L,U>,
     Unfolding: (\ @ g
                   @ a
                   ($dRandomGen :: System.Random.RandomGen g)
                   (xs :: [a]) ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case GHC.List.$wlenAcc @ a xs 0# of ww2 { DEFAULT ->
                     GHC.Integer.Type.smallInteger (GHC.Prim.-# ww2 1#) }
                 } in
                 (\ (s1 :: g) ->
                  let {
                    ds :: (GHC.Types.Int, g)
                    = case System.Random.$wrandomIvalInteger
                             @ g
                             @ GHC.Types.Int
                             $dRandomGen
                             GHC.Num.$fNumInt
                             Main.findTrade3
                             w1
                             s1 of ww2 { (#,#) ww3 ww4 ->
                      (ww3, ww4) }
                  } in
                  (let {
                     ri :: GHC.Types.Int = case ds of wild { (,) a1 s' -> a1 }
                   } in
                   (GHC.List.!! @ a xs ri, ri),
                   case ds of wild { (,) a1 s' -> s' })
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <((a, GHC.Types.Int), g)>_R)))
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <g>_N <Data.Functor.Identity.Identity>_R <(a, GHC.Types.Int)>_N))
                      (Sym (Control.Monad.Trans.Random.Lazy.N:RandT[0]) <g>_N <Data.Functor.Identity.Identity>_N <(a,
                                                                                                                   GHC.Types.Int)>_N))) -}
fe89c8da471f0b9e8762e4136390534f
  removeElem :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: [a]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$wremoveElem @ a ww1 w1 }) -}
2110f72b80b259849f1a6d57882a9907
  rngSeed :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 42#) -}
2ab0b5e3b162b3a032b1603aafc59681
  runSimulation ::
    System.Random.RandomGen g =>
    Control.Monad.Trans.Random.Lazy.Rand g [Main.Price]
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.runSimulation1
                  `cast`
                (forall (g :: <*>_N).
                 <System.Random.RandomGen g>_R
                 ->_R Trans
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <g>_N <Data.Functor.Identity.Identity>_R <[Main.Price]>_N))
                          (Sym (Control.Monad.Trans.Random.Lazy.N:RandT[0]) <g>_N <Data.Functor.Identity.Identity>_N <[Main.Price]>_N)) -}
0d61001cd5a4c42e40fff0d74d71f3c9
  runSimulation1 ::
    System.Random.RandomGen g =>
    g -> Data.Functor.Identity.Identity ([Main.Price], g)
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ g (w :: System.Random.RandomGen g) (w1 :: g) ->
                 case Main.$wrunSimulation @ g w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([Main.Price], g)>_R)) }) -}
4c59058bda7cf75fe81344df5c8776ab
  runSimulation_ival :: (GHC.Types.Double, GHC.Types.Double)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Main.findTrade2, Main.maxCost)) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  sellers :: Main.Market -> [Main.Seller]
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLL),1*U(1*U,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds1 }) -}
e6f27e9116f3a825ef47109ecfb5e0b3
  sellersCount :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 500#) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  surplus :: Main.Market -> Main.Price
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),1*U(A,A,A,A,A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds6 }) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  tradedCosts :: Main.Market -> [Main.Price]
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),1*U(A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds8 }) -}
1c0f2186a15c1342faa9a1b9d29eab6d
  tradedValues :: Main.Market -> [Main.Price]
  RecSel Left Main.Market
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),1*U(A,A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Market) ->
                 case ds of wild { Main.Market ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 ds7 }) -}
"SC:$w$siteration0" [0] forall (sc :: System.Random.StdGen)
                               (sc1 :: [Main.Seller])
                               (sc2 :: [Main.Buyer])
                               (sc3 :: GHC.Base.Maybe Main.Offer)
                               (sc4 :: GHC.Base.Maybe Main.Offer)
                               (sc5 :: [GHC.Types.Double])
                               (sc6 :: GHC.Prim.Double#)
                               (sc7 :: [GHC.Types.Double])
                               (sc8 :: [GHC.Types.Double])
                               (sc9 :: GHC.Prim.Int#)
  Main.$w$siteration sc9
                     (Main.Market sc1 sc2 sc3 sc4 sc5 (GHC.Types.D# sc6) sc7 sc8)
                     sc
  = Main.iteration_$s$w$siteration
      sc
      sc1
      sc2
      sc3
      sc4
      sc5
      sc6
      sc7
      sc8
      sc9
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

